#include <Wire.h>
#include "ds3231.h"
#include "groot.h"


void (*callbacks[5])(void);

grootAlarm Alarms[MAX_ALARMS];
uint8 gAlarmEnablers=0;  


/************************************************************************/
void grootRegisterAlarm(uint8 u8Alarm,uint8 u8hour,uint8 minutes,uint8 u8days,void (*f)())
{
     Alarms[u8Alarm].ghour = u8hour;
     Alarms[u8Alarm].gminute = minutes;
     Alarms[u8Alarm].gdays = u8days;
     callbacks[u8Alarm] = f;
}

/************************************************************************/
void grootInit(void)
{
    struct ts t; 
    char  buff[64];

    /*=== Valves Initialization     ===*/
    Serial.println("Inicializacion de Valvulas");
    pinMode(VALVE1,OUTPUT);
    pinMode(VALVE2,OUTPUT);
    pinMode(VALVE3,OUTPUT);
    pinMode(VALVE4,OUTPUT);
    pinMode(VALVE5,OUTPUT);
  
    digitalWrite(VALVE1,OFF);
    digitalWrite(VALVE2,OFF);
    digitalWrite(VALVE3,OFF);
    digitalWrite(VALVE4,OFF);
    digitalWrite(VALVE5,OFF);
  
    /*=== RTC Initialization     ===*/
    Serial.println("Inicializacion de Reloj de tiempo Real");
    Wire.begin();
    DS3231_init(DS3231_INTCN);
    DS3231_clear_a1f();
    DS3231_get(&t);



    
    // display current time
    Serial.print("hora/Fecha: ");
    snprintf(buff, 256, "%d.%02d.%02d %02d:%02d:%02d", t.year,
            t.mon, t.mday, t.hour, t.min, t.sec);
  
    Serial.println(buff);
    
}

/************************************************************************/
void grootSetDateTime(uint8 min,uint8 hour,uint8 mday,uint8 mon,uint8 year)
{
    struct ts t;

    // Uncomment this to setup RTC time (first time)
    t.year=(year+2000);
    t.mon=mon;
    t.mday=mday;
    t.hour=hour;
    t.min=min;
    t.sec=0;
  
    DS3231_set(t);
}

/************************************************************************/
void grootEnableAlarm(uint8 u8Alarm)
{
    gAlarmEnablers |= (1<<u8Alarm);
    grootActivateNextAlarm();
}

/************************************************************************/
uint8 grootReadAlarm(uint8 u8Alarm)
{
    return(gAlarmEnablers);
}

/************************************************************************/
void grootDisableAlarm(uint8 u8Alarm)
{
    gAlarmEnablers &= ~(1<<u8Alarm);
    grootActivateNextAlarm();
}




/************************************************************************/
void grootService(void)
{
    struct ts currentTime;
    char  buff[64];
    uint8 u8Index=0;
    uint8 u8Counter=0;
    
    
    /**************************************************/
    // Check if alarm was generated by RTC.. New Event
    /**************************************************/
    if (DS3231_triggered_a1()) 
    {
      // clear a1 alarm flag and let INT go into hi-z
      DS3231_clear_a1f();   
      
      // read Current Time from RTC
      DS3231_get(&currentTime);
    
      while((currentTime.min != Alarms[u8Index].gminute) || (currentTime.hour != Alarms[u8Index].ghour) && u8Index<MAX_ALARMS)
      {
        u8Index++;
      }    

      if(u8Index == MAX_ALARMS)
      {
        Serial.print("error");
        return;
      }


      u8Counter = DayOfWeek(currentTime);
      Serial.print("Hoy es ");
      Serial.println(u8Counter,DEC);
      
      if(Alarms[u8Index].gdays & (1<<u8Counter))
      {
          Serial.print("Alarma ");
          Serial.print(u8Index,DEC);
          Serial.print("    ");
              
              Serial.print("date/Time: ");
          snprintf(buff, 256, "%d.%02d.%02d %02d:%02d:%02d", currentTime.year,
                currentTime.mon, currentTime.mday, currentTime.hour, currentTime.min, currentTime.sec);
        
          Serial.println(buff);
    
          /* Callback user function call */
          callbacks[u8Index]();
       
      }
      else
      {
          Serial.println("Hoy no esta activada la Alarma: ");
          Serial.print(u8Index,DEC);          
      }

      /* check for next Alarm */
      grootActivateNextAlarm();

    }
}


/************************************************************************/
uint8 grootLookNextAlarm(uint8 u8hour,uint8 u8Min)
{
    int actualMagic=0;
    int NewMagic=0;
    int process=0;
    
    uint8 u8Counter;
    uint8 u8Index;

    actualMagic = (u8hour * 100) + u8Min;
    
    u8Index =20;
    NewMagic = 10000;
    //Serial.print("=========");
    //Serial.println(actualMagic);
    
    for(u8Counter=0;u8Counter<MAX_ALARMS;u8Counter++)
    {
        process = (Alarms[u8Counter].ghour * 100) + Alarms[u8Counter].gminute;
        //Serial.print(u8Counter);
        //Serial.print("    ");
        //Serial.print(process);
        //Serial.print("    ");
        //Serial.println(NewMagic);
        
        if((actualMagic < process) &&
          (NewMagic > process))
        {
          NewMagic = process;
          u8Index = u8Counter;
        }
    }
        //Serial.println(u8Index);
    if(u8Index<20)
      return(u8Index);
  
    
    u8Index =20;
    NewMagic = 10000;
    actualMagic = 0;
    for(u8Counter=0;u8Counter<MAX_ALARMS;u8Counter++)
    {
        process = (Alarms[u8Counter].ghour * 100) + Alarms[u8Counter].gminute;
        //Serial.print(u8Counter);
        //Serial.print("    ");
        //Serial.print(process);
        //Serial.print("    ");
        //Serial.println(NewMagic);
        
        if((actualMagic <= process) &&
          (NewMagic > process))
        {
          NewMagic = process;
          u8Index = u8Counter;
        }
    }
    
    
    //Serial.println(u8Index);
    return(u8Index);
}


/************************************************************************/
uint8 grootActivateNextAlarm(void)
{
    struct ts currentTime;
    uint8 u8Index=20;
    uint8 u8cycles=0;
    
    if(gAlarmEnablers)
    {
       
      DS3231_get(&currentTime);
  
  
      while(u8cycles < MAX_ALARMS)
      {
        u8Index = grootLookNextAlarm(currentTime.hour,currentTime.min);
         
        if(gAlarmEnablers & (1<<u8Index))
        {
          Serial.print("Siguiente Alarma: ");
          Serial.print(u8Index,DEC);
          Serial.print("  Hora: ");
          Serial.print(Alarms[u8Index].ghour,DEC);
          Serial.print(":");
          Serial.println(Alarms[u8Index].gminute,DEC);
          set_RTC_alarm(Alarms[u8Index].ghour,Alarms[u8Index].gminute);    
          u8cycles = MAX_ALARMS;
        }
        else
        {
          currentTime.hour = Alarms[u8Index].ghour;
          currentTime.min = Alarms[u8Index].gminute;
        }
      }
    }
      
}
/*********************************************************************/
void set_RTC_alarm(uint8 u8hour,uint8 u8Min)
{

    // flags define what calendar component to be checked against the current time in order
    // to trigger the alarm - see datasheet
    // A1M1 (seconds) (0 to enable, 1 to disable)
    // A1M2 (minutes) (0 to enable, 1 to disable)
    // A1M3 (hour)    (0 to enable, 1 to disable) 
    // A1M4 (day)     (0 to enable, 1 to disable)
    // DY/DT          (dayofweek == 1/dayofmonth == 0)
    uint8_t flags[5] = { 0, 0, 0, 1, 1 };

    // set Alarm1
    DS3231_set_a1(0, u8Min, u8hour, 0, flags);



    // activate Alarm1
    DS3231_set_creg(DS3231_INTCN | DS3231_A1IE);
}

/************************************************************************/
uint8 DayOfWeek(struct ts lTime)
{
    int weekday;
    
    // Check Current Day
    weekday  = (lTime.mday += lTime.mon < 3 ? lTime.year-- : lTime.year - 2, 23*lTime.mon/9 + lTime.mday + 4 + lTime.year/4- lTime.year/100 + lTime.year/400)%7;
    return(weekday);
}

/*********************************************************************/
void grootTestValves(int u16Delay)
{
    digitalWrite(VALVE1,HIGH);
    delay(u16Delay);
    digitalWrite(VALVE1,LOW);
    delay(u16Delay);  
    digitalWrite(VALVE2,HIGH);
    delay(u16Delay);
    digitalWrite(VALVE2,LOW);
    delay(u16Delay); 
    digitalWrite(VALVE3,HIGH);
    delay(u16Delay);
    digitalWrite(VALVE3,LOW);
    delay(u16Delay);
    digitalWrite(VALVE4,HIGH);
    delay(u16Delay);
    digitalWrite(VALVE4,LOW);
    delay(u16Delay);
    digitalWrite(VALVE5,HIGH);
    delay(u16Delay);
    digitalWrite(VALVE5,LOW);
    delay(u16Delay); 
}
